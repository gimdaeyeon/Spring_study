# 스프링 AOP 구현
## 스프링 AOP 구현5 - 어드바이스 순서
어드바이스는 기본적으로 순서를 보장하지 않는다. 순서를 지정하고 싶으면 `@Aspect`적용 위로   
`ort.springframework.core.annotation.@Order`애노테이션을 적용해야한다. 문제는 이것을 어드바이스 단위가 아니라 클래스 단위로 적용할 수 있다는 점이다.   
그래서 지금처럼 하나의 애프펙트에 여러 어드바이스가 있으면 순서를 보장 받을 수 없다. 따라서 **애스펙트를 별도의 클래스로 분리**해야한다.

## 스프링 AOP 구현6 - 어드바이스 종류
어드바이스는 앞서 살펴본 `@Around`외에도 여러가지 종류가 있다.

#### 어드바이스 종류
- `@Around`: 메서드 호출 전후에 수행, 가장 강력한 어드바이스,조인 인트 실행 여부 선택, 값 변환, 예외 변환 등이 가능
- `@Before`: 조인 포인트 실행 이전에 실행
- `@After Returning`: 조인 포인트가 정상 완료후 실행
- `@After Throwing`: 메서드가 예외를 던지는 경우 실행
- `@After`: 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)

### 참고 정보 획득
모든 어드비이스는 `org.aspect.lang.JoinPoint`를 첫번째 파라미터에 사용할 수 있다.(생략해도 된다.)   
단 `@Around`는 `ProceedingJoinPoint`를 사용해야한다.

참고로 `ProceedingJoinPoint`는 `org.aspect.lang.JoinPoint`의 하위타입이다. 

### **JoinPoint** 인터페이스의 주요 기능
- `getArgs()`: 메서드 인수를 반환합니다.
- `getThis()`: 프록시 객체를 반환합니다.
-  `getTarget()`: 대상 객체를 반환합니다.
-  `getSignature()`: 조인되는 메서드에 대한 설명을 반환합니다.
-  `toString()`: 조인되는 방법에 대한 유용한 설명을 인쇄합니다.

### **ProceedingJoinPoint** 인터페이스의 주요 기능
- `proceed()`: 다음 어드바이스나 타겟을 호출한다.

# 스프링 AOP - 포인트컷
## 포인트컷 지시자
애스펙트J는 포인트컷을 편리하게 표현하기 위해 특별한 표현식을 제공한다.   
예) `@Pointcut("execution(* hello.aop.order..*(..))")`   
포인트컷 표현식은 AspejtJ pointcut expression 즉 애스펙트J가 제공하는 포인트컷 표현식을 줄여서 말하는 것이다.

### 포인트컷 지시자
포인트컷 표현식은 `execution`가틍ㄴ 포인트컷 지시자(Pointcut designator)로 시작한다. 줄여서PCD라 한다.

### 포인트컷 지시자의 종류
- `execution`: 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡하다.
- `within`: 특정 타입 내의 조인포인트를 매칭한다.
- `args`: 인자가 주어진 타입의 인스턴스인 조인 포인트
- `this`: 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
- `target`: Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
- `@warget`: 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
- `@within`: 주어진 애노테이션이 있는 타입 내 조인 포인트
- `@annotation`: 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
- `@args`: 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
- `bean`: 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다.

# 스프링 AOP - 실무 주의사항

## 프록시와 내부 호출 - 문제

스프링은 프록시 방식의AOP를 사용한다.   
따라서 AOP를 적용하려면 항상 프록시를 통해서 해당 객체(Target)을 호출해야 한다.   
이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.   
만약 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP각 적용되지 않고, 어드바이스도 호출되지 않는다.

AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록한다. 따라서 스프링은 의존관계 주입시에 항상 프록시 객체를 주입한다.   
프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다. 하지만 대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고
대상 객체를 직접 호출하는 문제가 발생한다.











